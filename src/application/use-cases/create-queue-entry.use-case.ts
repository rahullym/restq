/**
 * Create Queue Entry Use Case
 * Application-level business logic for creating queue entries
 */
import { QueueEntry } from '@/domain/entities/queue-entry'
import { IQueueEntryRepository } from '@/infrastructure/repositories/queue-entry.repository'
import { IRestaurantRepository } from '@/infrastructure/repositories/restaurant.repository'
import { ITokenSequenceRepository } from '@/infrastructure/repositories/token-sequence.repository'
import { QueueEntryStatus } from '@prisma/client'
import { Result } from '@/shared/types/result'
import { QueueEntryInput } from '@/shared/validation/schemas'
import { PrismaClient } from '@prisma/client'

export interface CreateQueueEntryResult {
  entry: QueueEntry
  position: number
}

export class CreateQueueEntryUseCase {
  constructor(
    private queueEntryRepo: IQueueEntryRepository,
    private restaurantRepo: IRestaurantRepository,
    private tokenSequenceRepo: ITokenSequenceRepository,
    private prisma: PrismaClient
  ) {}

  async execute(
    restaurantId: string,
    input: QueueEntryInput
  ): Promise<Result<CreateQueueEntryResult>> {
    // Check idempotency first (fast path)
    if (input.idempotencyKey) {
      const existing = await this.queueEntryRepo.findByIdempotencyKey(
        input.idempotencyKey
      )
      if (existing) {
        const position = await this.queueEntryRepo.countWaitingBefore(
          restaurantId,
          existing.createdAt
        )
        return Result.ok({
          entry: existing,
          position: position + 1,
        })
      }
    }

    // Execute in transaction for atomicity
    return await this.prisma.$transaction(async (tx) => {
      // Verify restaurant exists
      const restaurant = await this.restaurantRepo.findById(restaurantId)
      if (!restaurant) {
        return Result.error(new Error('Restaurant not found'))
      }

      // Generate token atomically
      const tokenResult = await this.tokenSequenceRepo.getNextToken(
        restaurantId,
        tx
      )
      if (!tokenResult.success) {
        return tokenResult
      }

      // Count waiting entries for position snapshot
      const waitingCount = await this.queueEntryRepo.countWaiting(restaurantId)

      // Create queue entry
      const entry = new QueueEntry({
        id: '', // Will be generated by DB
        restaurantId,
        name: input.name,
        mobileNumber: input.mobileNumber,
        partySize: input.partySize || 2,
        seatingType: input.seatingType || null,
        status: QueueEntryStatus.WAITING,
        tokenNumber: tokenResult.data,
        positionSnapshot: waitingCount + 1,
        idempotencyKey: input.idempotencyKey || null,
        createdAt: new Date(),
        updatedAt: new Date(),
      })

      const createResult = await this.queueEntryRepo.create(entry)
      if (!createResult.success) {
        return createResult
      }

      return Result.ok({
        entry: createResult.data,
        position: waitingCount + 1,
      })
    }, {
      timeout: 5000,
      isolationLevel: 'ReadCommitted',
    })
  }
}
